/* This file is generated by the cgen program, https://github.com/morten-krogh/cgen. The cgen program is released under the MIT license.*/

#include "store_int_int.h"

#include <stdlib.h>
#include <string.h>

struct kv_store_int_int *kv_store_int_int_init(struct kv_store_int_int *store, int (*compar)(int key1, int key2))
{
	store->compar = compar;
	store->data = NULL;
	store->size = 0;
	store->capacity = 0;

	return store;
}

void kv_store_int_int_free(struct kv_store_int_int *store)
{
	free(store->data);
}

/* The key is searched in store. lower and upper are the return values. The key woth index lower is
 * less than or equal to key. The key with index upper is greater than or equal to key.  lower is at
 * most upper. lower can be -1 which means that key is below the first element in the store.  upper
 * can be size which means that the key is larger than all keys in the store. The compar function is
 * used for comparison. If upper == lower, the key is present in the store.
 */

static void kv_store_int_int_search(struct kv_store_int_int *store, int key, ptrdiff_t *lower, ptrdiff_t *upper)
{
	ptrdiff_t low = -1;
	ptrdiff_t high = store->size;
	ptrdiff_t middle = (low + high) / 2;
	while (middle > low && middle < high) {
		int cmp = store->compar(key, store->data[middle].key);
		if (cmp > 0) {
			low = middle;
		} else if (cmp < 0) {
			high = middle;
		} else {
			low = middle;
			high = middle;
			break;
		}
		middle = (low + high) / 2;
	}

	*lower = low;
	*upper = high;

	return;
}

int *kv_store_int_int_get(struct kv_store_int_int *store, int key)
{
	ptrdiff_t lower;
	ptrdiff_t upper;
	kv_store_int_int_search(store, key, &lower, &upper);
	if (lower == upper) {
		return &store->data[lower].value;
	} else {
		return NULL;
	}
}

/* The value is inserted for the key. If the key is present, the value replaces the present value.
 * The bool return value is true if the key was present and false if the key was absent. 
 */
bool kv_store_int_int_put(struct kv_store_int_int *store, int key, int value)
{
	ptrdiff_t lower;
	ptrdiff_t upper;
	kv_store_int_int_search(store, key, &lower, &upper);

	if (lower == upper) {
		store->data[lower].value = value;
		return true;
	} else {
		if (store->size == store->capacity) {
			size_t new_capacity = 2 * store->capacity + 1;
			struct kv_tuple_int_int *new_data = realloc(store->data, new_capacity * sizeof(struct kv_tuple_int_int));
			if (new_data == NULL) return false;
			store->data = new_data;
			store->capacity = new_capacity;
		}
		if (upper < store->size) {
			memmove(store->data + (upper + 1), store->data + upper, (store->size - upper) * sizeof(struct kv_tuple_int_int));
		}
		store->data[upper].key = key;
		store->data[upper].value = value;
		store->size++;
		return false;
	}
	
}

/* The value is deleted for the key. The bool return value is true if the key was present and false
 * if the key was absent.
 */

#include<stdio.h> // REMOVE

bool kv_store_int_int_delete(struct kv_store_int_int *store, int key)
{
	ptrdiff_t lower;
	ptrdiff_t upper;
	kv_store_int_int_search(store, key, &lower, &upper);
	printf("lower = %zu, upper = %zu, sizeof = %zu\n", lower, upper, sizeof(struct kv_tuple_int_int));

	
	if (lower == upper) {
		memcpy(store->data + lower, store->data + lower + 1, (store->size - lower - 1) * sizeof(struct kv_tuple_int_int));
		store->size--;
		return true;
	} else {
		return false;
	}
}
